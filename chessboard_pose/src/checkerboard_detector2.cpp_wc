// Software License Agreement (BSD License)
// Copyright (c) 2008, Willow Garage, Inc.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//   * The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// author: Rosen Diankov
// adapted: chris
#include <cstdio>
#include <vector>
#include <sstream>
#include <ros/ros.h>

#include <boost/thread/mutex.hpp>
#include <boost/format.hpp>
#include "opencv/cv.h"
#include "opencv/highgui.h"
#include "cv_bridge/CvBridge.h"
#include "sensor_msgs/CameraInfo.h"
#include "sensor_msgs/Image.h"
#include "geometry_msgs/PoseStamped.h"
#include "geometry_msgs/PoseArray.h"
#include "math.h"
#include <image_transport/image_transport.h>

#include <tf/transform_broadcaster.h>


#include <sys/timeb.h>
#include <sys/time.h>

#define sqr(a) ((a)*(a))

using namespace std;
using namespace ros;
using namespace boost;

class ChessBoardDetector {

public:
	struct ChessBoard {
		CvSize griddims; ///< number of squares
		vector<CvPoint3D64f> grid3d;
		vector<CvPoint2D32f> corners;
		TransformMatrix tlocaltrans;
		TransformMatrix previous_pose;
		double cellwidth;
		double cellheight;
		geometry_msgs::PoseStamped pose;
	} chessboard;

	sensor_msgs::CvBridge _cvbridge;
	sensor_msgs::CameraInfo _camInfoMsg;

	ros::Subscriber camInfoSubscriber;
	image_transport::Subscriber imageSubscriber;
	ros::Publisher posePublisher;


	int display, verbose;
	ros::Time lasttime;
	CvMat *intrinsic_matrix; // intrinsic matrices
	boost::mutex mutexcalib;
	IplImage* frame;

	bool publishTF;

	ros::NodeHandle _node_private;
	ros::NodeHandle _node_pub;

	tf::TransformBroadcaster trans_broad;
	tf::Transform transform;

	std::string name;

	//////////////////////////////////////////////////////////////////////////////
	// Constructor
	ChessBoardDetector() :
			intrinsic_matrix(NULL), frame(NULL), publishTF(false), _node_private("~") {

		_node_private.param("display", display, 1);
		_node_private.param("verbose", verbose, 1);
		_node_private.param("publish_tf", publishTF, true);

//		_node_private.param("name", name, "/chessboard");
		name="/chessboard";

		ROS_INFO("Creating chessboard detector.");
		int dimx, dimy;
		double fRectSize[2];

		if (!_node_private.getParam("grid_x_size", dimx)) {
			ROS_ERROR("Missing parameter: grid_x_size");
			return;
		}
		if (dimx < 3) {
			ROS_ERROR("Param: grid x size must be greater than 2");
			return;
		}

		if (!_node_private.getParam("grid_y_size", dimy)) {
			ROS_ERROR("Missing parameter: grid_y_size");
			return;
		}
		if (dimy < 3) {
			ROS_ERROR("Param: grid y size must be greater than 2");
			return;
		}

		if (!_node_private.getParam("rect_x_size", fRectSize[0])) {
			ROS_ERROR("Missing parameter: rect_x_size");
			return;
		}

		if (!_node_private.getParam("rect_y_size", fRectSize[1])) {
			ROS_ERROR("Missing parameter: rect_y_size");
			return;
		}

		ROS_INFO("Board: %d X %d, %f x %f;",dimx,dimy,fRectSize[0],fRectSize[1]);
		chessboard.griddims = cvSize(dimx, dimy);
		chessboard.cellwidth = fRectSize[0];
		chessboard.cellheight = fRectSize[0];

		chessboard.grid3d.resize(dimx * dimy);
		int j = 0;
		for (int y = 0; y < dimy; ++y)
			for (int x = 0; x < dimx; ++x)

				chessboard.grid3d[j++] = cvPoint3D64f(x * fRectSize[0],
						y * fRectSize[1], 0);

		if (display) {
			cvNamedWindow("Checkerboard Detector", CV_WINDOW_AUTOSIZE);
//			cvStartWindowThread();
		}

		posePublisher = _node_pub.advertise<geometry_msgs::PoseStamped>(name+"_pose", 1);


		this->camInfoSubscriber = _node_pub.subscribe("camera_info", 1,
				&ChessBoardDetector::caminfo_cb, this);
		image_transport::ImageTransport it(_node_pub);
		this->imageSubscriber = it.subscribe("image_rect", 1,
				&ChessBoardDetector::image_cb, this);



	}

	//////////////////////////////////////////////////////////////////////////////
	// Destructor
	virtual ~ChessBoardDetector() {
		if (frame)
			cvReleaseImage(&frame);
		if (this->intrinsic_matrix)
			cvReleaseMat(&this->intrinsic_matrix);
		this->camInfoSubscriber.shutdown();
		this->imageSubscriber.shutdown();
	}

	//////////////////////////////////////////////////////////////////////////////
	// Camera info callback
	void caminfo_cb(const sensor_msgs::CameraInfoConstPtr &msg) {
		boost::mutex::scoped_lock lock(this->mutexcalib);

		this->_camInfoMsg = *msg;
	}

	//////////////////////////////////////////////////////////////////////////////
	// Image data callback
	void image_cb(const sensor_msgs::ImageConstPtr &msg) {
		boost::mutex::scoped_lock lock(this->mutexcalib);
		if (Detect(*msg, this->_camInfoMsg)) {
			posePublisher.publish(chessboard.pose);
			if (verbose>0){
				ROS_INFO_STREAM("Chess board found, pose: "<<chessboard.pose.pose);
			}
			if (publishTF) {
				transform.setOrigin( tf::Vector3(chessboard.pose.pose.position.x,
						chessboard.pose.pose.position.y,
						chessboard.pose.pose.position.z) );
				transform.setRotation( tf::Quaternion(chessboard.pose.pose.orientation.x,
						chessboard.pose.pose.orientation.y,
						chessboard.pose.pose.orientation.z,
						chessboard.pose.pose.orientation.w) );
				trans_broad.sendTransform(tf::StampedTransform(transform, ros::Time::now(), msg->header.frame_id, name));
			}
		}
	}

	bool Detect(const sensor_msgs::Image& imagemsg,
			const sensor_msgs::CameraInfo& camInfoMsg) {

		if (this->intrinsic_matrix == NULL)
			this->intrinsic_matrix = cvCreateMat(3, 3, CV_32FC1);



		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 3; ++j)
				this->intrinsic_matrix->data.fl[3 * i + j] = camInfoMsg.P[4 * i + j];

		if (!_cvbridge.fromImage(imagemsg, "mono8")) {
			ROS_ERROR("failed to get image");
			return false;
		}

		IplImage *pimggray = _cvbridge.toIpl();
		if (display) {
			// copy the raw image
			if (frame != NULL
					&& (frame->width != (int) imagemsg.width
							|| frame->height != (int) imagemsg.height)) {
				cvReleaseImage(&frame);
				frame = NULL;
			}

			if (frame == NULL)
				frame = cvCreateImage(cvSize(imagemsg.width, imagemsg.height),
						IPL_DEPTH_8U, 3);

			cvCvtColor(pimggray, frame, CV_GRAY2RGB);
		}

		chessboard.corners.resize(200);
		int ncorners;
		int allfound = cvFindChessboardCorners(pimggray, chessboard.griddims,
				&chessboard.corners[0], &ncorners, CV_CALIB_CB_ADAPTIVE_THRESH);
		chessboard.corners.resize(ncorners);

		if (display) {
			cvDrawChessboardCorners(frame,  chessboard.griddims, &chessboard.corners[0], ncorners, allfound);
			cvShowImage("Chessboard Detector", frame);
			cvWaitKey(10);
		}

		if (!allfound || ncorners != (int) chessboard.grid3d.size()){
			return false;
		}

		// remove any corners that are close to the border
		const int borderthresh = 30;

		for (int j = 0; j < ncorners; ++j) {
			int x = chessboard.corners[j].x;
			int y = chessboard.corners[j].y;
			if (x < borderthresh || x > pimggray->width - borderthresh
					|| y < borderthresh
					|| y > pimggray->height - borderthresh) {
				allfound = 0;
				return false;
			}
		}

		if (allfound) {
			cvFindCornerSubPix(pimggray, &chessboard.corners[0],
					chessboard.corners.size(), cvSize(5, 5), cvSize(-1, -1),
					cvTermCriteria(CV_TERMCRIT_ITER, 20, 1e-2));

			chessboard.pose.pose = FindTransformation(chessboard.corners, chessboard.grid3d,
					chessboard.tlocaltrans, chessboard);

			chessboard.pose.header.stamp = imagemsg.header.stamp;
			chessboard.pose.header.frame_id = imagemsg.header.frame_id;

			return true;

		} else
			return false;

	}

	//////////////////////////////////////////////////////////////////////////////
	// FindTransformation
	geometry_msgs::Pose FindTransformation(const vector<CvPoint2D32f> &imgpts,
			const vector<CvPoint3D64f> &objpts, const Transform& tlocal,
			ChessBoard &cb) {
		CvMat *objpoints = cvCreateMat(3, objpts.size(), CV_32FC1);
		for (size_t i = 0; i < objpts.size(); ++i) {
			cvSetReal2D(objpoints, 0, i, objpts[i].x);
			cvSetReal2D(objpoints, 1, i, objpts[i].y);
			cvSetReal2D(objpoints, 2, i, objpts[i].z);
		}

		geometry_msgs::Pose pose;
		Transform tchecker;
		assert(sizeof(tchecker.trans.x)==sizeof(float));
		float fR3[3];
		CvMat R3, T3;
		assert(sizeof(pose.position.x) == sizeof(double));
		cvInitMatHeader(&R3, 3, 1, CV_32FC1, fR3);
		cvInitMatHeader(&T3, 3, 1, CV_32FC1, &tchecker.trans.x);

		float kc[4] = { 0 };
		CvMat kcmat;
		cvInitMatHeader(&kcmat, 1, 4, CV_32FC1, kc);

		CvMat img_points;
		cvInitMatHeader(&img_points, 1, imgpts.size(), CV_32FC2,
				const_cast<CvPoint2D32f*>(&imgpts[0]));

		cvFindExtrinsicCameraParams2(objpoints, &img_points,
				this->intrinsic_matrix, &kcmat, &R3, &T3);
		cvReleaseMat(&objpoints);

		double fang = sqrt(fR3[0] * fR3[0] + fR3[1] * fR3[1] + fR3[2] * fR3[2]);
		if (fang >= 1e-6) {
			double fmult = sin(fang / 2) / fang;
			tchecker.rot = Vector(cos(fang / 2), fR3[0] * fmult, fR3[1] * fmult,
					fR3[2] * fmult);
		}

		// move pose to center of marker
		Transform center(
				Vector(1, 0, 0, 0),
				Vector(cb.cellwidth * (cb.griddims.width - 1) / 2.0,
						cb.cellheight * (cb.griddims.height - 1) / 2.0, 0));

		// disambiguate by tracking..
		Transform rot180(Vector(1, 0, 0, 0), Vector(0, 0, 0));
		rot180.rotfromaxisangle(Vector(0, 0, 1), (float) M_PI);

		Transform tglobal1 = tchecker * center * tlocal;
		Transform tglobal2 = tchecker * center * rot180 * tlocal;
		TransformMatrix diff1(cb.previous_pose.inverse() * tglobal1);
		TransformMatrix diff2(cb.previous_pose.inverse() * tglobal2);

		Transform tglobal;
		if (diff1.m[0] >= 0)
			tglobal = tglobal1;
		else
			tglobal = tglobal2;

		cb.previous_pose = tglobal;

		pose.position.x = tglobal.trans.x;
		pose.position.y = tglobal.trans.y;
		pose.position.z = tglobal.trans.z;
		pose.orientation.x = tglobal.rot.y;
		pose.orientation.y = tglobal.rot.z;
		pose.orientation.z = tglobal.rot.w;
		pose.orientation.w = tglobal.rot.x;
		return pose;
	}
};

////////////////////////////////////////////////////////////////////////////////
// MAIN
int main(int argc, char **argv) {
	ros::init(argc, argv, "chessboard_pose");
	if (!ros::master::check())
		return 1;

	ChessBoardDetector cd;
	ros::spin();

	return 0;
}
